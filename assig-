`emit['ExpressionStatement'](n) {
  if n.type == 'AssignmentExpression' {
    var assig = n.expression
    return `emitAssignment(assig, EMIT_STATEMENT) 
  }

  `emit(n.expression)
  `code += ';'
}

`emitAssignmentExpr(assig, isStatement) {
   if assig.left.type == 'Identifier' {
     `emitIDAssignment(assig)
     if isStatement: `code += ';'
   } else:
     `assigEmitters[assig.left.type].call(
        this, assig.left, assig.right, -1, "", isStatement);
     
}

`emitIDAssignment(assig) {
   var hasParen = `prec !== PREC_WITH_NO_OP
   if hasParen: `write('(')
    
   `emit(assig.left)
   `write(assig.operator)
   var currentPrec = `prec 
   `prec = PREC_WITH_NO_OP
   `emit(assig.right)
   `prec = currentPrec
}

`assigEmitters['ArrayPattern'](left, right, idx, tempName, isStatement) {
   var list = left.elements
   if list.length == 0: 
      return

   var isRoot = tempName == ""
   if isRoot {
     tempName = `scope.surroundingFuncScope.allocateTemp()
     `write(tempName;' = ')
     `emitNonSeqExpr(right)
   }
   
   var e = 0
   while e < list.length {
     `writeSOESeparator(isStatement)
     `writeArrayAssigElem(list[e], val, e, tempName, isStatement)
     e++
   }

   if isRoot && !isStatement {
      `write(', ')
      `write(tempName)
   }
}

`writeArrayAssigElem(elem, idx, tempName, isStatement) {
    var left = elem, right = null
    if elem.type == 'AssignmentPattern' {
       left = elem.left
       right = elem.right
    }

    if left.type == 'Identifier' {
       `write(left.name;'=';tempName;'.length>';idx;' ? ';tempName;'[';idx;'] : ')
       if right:
        return `emit(right)
       else:
        return `write('void 0')
    }
    else {
      var t = `scope.surroundingFuncScope.allocateTemp()
      `write(t;' = ';tempName;'.length>';idx;' ? ';tempName;'[';idx;'] : ')
      if right:
         `emit(right)
      else:
         `write('void 0')

      `assigEmitters[left.type].call(
          this, left, right, tempName, isStatement)

      `scope.surroundingFunc.releaseTemp(temp)
    }
}

`assigEmitters['ObjectPattern'](left, right, name, isStatement) {
   var list = left.properties
   if list.length == 0:
     return

   var isRoot = tempName == ""
   if isRoot {
      var containerName = name
      name = `scope.surroundingFuncScope.allocateTemp()
      `write(name;' = ')
      `emitNonSeqExpr(right, PREC_WITH_NO_OP);
   }
   
   var e = 0
   while e < list.length {
      `emitObjAssigElem(list[e], name, isStatement);
      e++ ;
   }
}     

`emitObjAssigElem(elem, containerName, isStatement) {
   var v = elem.value, k = elem.k;
   var left = v, right = null;

   if ( v.type == 'AsignmentPattern' ) {
     left = v.left
     right = v.right
   }

   var elemName = ""
   if elem.computed {
      elemName = `scope.surroundingFunc.allocateTemp()
   }

   if left.type == 'Identifier' {
      if elem.computed {
         `write(elemName;' = ')
         `emitNonSeqExpr(k)
      }

      `write(left.name;' = ';containerName);
      if elem.computed:
         `write('[';elemName;']')
      else if k.type == 'Identifier' {
         `write('.')
         `emit(k)
      }
      else {
         `write('[')
         `emit(k)
         `write(']')
      }
   }
}                
   
             

