(yield)[yield] = yield
yield
a = sent
yield
b = sent
yield
a[b] = sent

[ (yield)[yield] ] = yield
yield
a = sent
yield
b = sent
yield
[ a[b] ] = sent

[ (yield)[yield] = yield ] = l() * yield
yield
a = sent
yield
b = sent
yield

[a,b] = e
_temp = arrDec(e)
a = _temp.get()
b = _temp.get()

{a: _a, b: _b} = e
_temp = objDec(e)
_a = _temp.get('a')
_b = _temp.get('b')

[a[b]] = l()
_temp = a
_temp1 = b
_e = arrIter(l())
a[b] = _.get()

[a[b]=yield]=l()
t1_=a
t2_=b
e_ =arrIter(l())
l_ =_e.get()
if l_ == void 0 { 
  yield
  l_ = sent
}
l_ = arrIter(l_)
temp_[temp1_] = l_.get()

[(yield)[yield]=yield, [a[b]=yield, a[a()]]] = l()
yield
a1=sent
yield
b1=sent
a2=a
b2=b
an=a
bn=a()
e=arrIter(l())
if (e1=e.get()) == void 0 {
  yield
  e1=sent
}
a1[b1]=e1
e1=arrIter(e.get())
e2=e1.get()
if e1 == void 0 {
  yield
  e2 = sent
}
a2[b2]=e2
an[bn]=e1.get()

(yield)[yield] = l()
yield
a = sent
yield
a[sent] = l()

a[b] = yield
_temp = a
_temp2 = b
yield
_temp[_temp2] = sent

var type = n.left.type
assignmentTransformers[type].call(this, n, b, vMode)

[l()[e]] = yield
a = l()
b = e
yield
_temp = arrIter(sent)
`transformExecutableComponents(n.left)

[(yield)[yield]] = l()
yield
a = sent
yield
[a[sent]] = l()
e = arrIter(l())
a[sent]= e.get()

[(yield)[yield]] = yield
yield
a = sent
yield
b = sent
yield
[a[b]]=sent ->
  e = arrIter(sent)
  a[b] = e.get()

[(yield)[yield], (yield)[yield]=yield] = yield
yield
a = sent
yield
b = sent
yield
e = sent
yield
l = sent
yield
_temp = arrIter(sent)
a[b]=_temp.get()
_temp1 = _temp.get()
if unOrNull(_temp1) {
  yield
  _temp1 = sent
}
e[l] = _temp1
 
[a, b=yield] = 12
e = arrIter(12)
a = e.get()
_temp = e.get()
if unOrNull(b) {
  yield
  _temp = sent
}

a = (yield) && (yield)
yield
if(a1 = sent) {
  yield
  a1 = sent
}
a = a1

[(yield)[yield], (yield)[yield]] = yield
yield
a1 = sent
yield
b1 = sent
yield
a2 = sent
yield
b2 = sent
yield
[a1[b1], a2[b2]] = sent

[(yield)[yield], (yield)[yield]=yield]=yield
yield
a1 = sent
yield
b1 = sent
yield
a2 = sent
yield
b2 = sent
yield
_temp = arrIter(sent)
a1[b1] = _temp.get()

if unOrNull(a1 = _temp.get()) {
  yield
  a1 = sent
}

a2[b2]=a1

assigTransformers['ArrayPattern'] = function(n, b, vMode) {
  var hasDefaultYield = false
  var list = n.left
  var e = 0
  var tempList = []
  
{[yield 'a']: a, [yield 'b']: b} = 12
yield 'a'
a1 = sent

yield 'b'
a2 = sent

_temp = objIter(12)
a = _temp.get(a1)
b = _temp.get(a2)

{a: a} = yield
yield
{a: a} = sent

{[l()]: a} = yield
a1 = l()
yield
{[a1]: a} = sent // THIS IS NOT THE WAY IT SHOULD BE DONE, because 'a1', if released after transformation, 
                 // might be actually re-allocated by the emitter as the temp that holds arrIter(sent),
                 // thus overwriting the original a1
_temp = arrIter(sent)
a = _temp.get()

// a transform can be consider'd finished only if the node it has transformed has made no _temp allocations, or else if it would
// require no further _temp allocation when it reaches the 'emit' phase

[a, b] = yield
yield
[a, b] = sent // no temp allocated -- leave any further work to the emitter

[a()[0]] = yield
a1 = a
yield
[a1[0]] = sent // 'a1' allocated, and emitting it would require further allocations, so keep on transforming
  _temp = arrIter(sent)
  a1[0] = _temp.get()

[a()[l()]] = [(yield)[0]] = l()

[(yield)[0]] = l()
yield
a = sent
// NOT [a[0]] = l()

_temp = arrIter(l())
a[0] = _temp.get()

[l()[0]=yield] = e()
a = l()
// NOT [a[0]=yield] = e()

_temp = arrIter(e())
b = _temp.get()
if unOrNull(b) {
  yield
  b = sent
}
a[0] = b

[l()[0]] = yield
a = l()
yield
// NOT [a[0]]=sent

_temp = arrIter(sent)
a[0] = _temp.get()

transform_an_assignment_whose_left_is['ArrayPattern'] = function(n, b, vMode) {
    if !y(n): return n

    var tempList = []
    var hasDefaultYield = `prepareLeft(n.left, b, tempList)
    
                  
n = transformAssig[n.left.type].call(this, n, b)
if n.type === 'AssignmentExpression': return n
return vMode ? n#memS(VAL) : NOEXPRESSION

[(yield)[(yield) * ((yield) * (yield))] = (yield)[yield]
    c            b                               a

<alloc>=a
<alloc>=b
<alloc>=c
<free(c)>
yield
<alloc>=c
c = sent
<free(b)>
yield
<alloc>=b
b = sent
yield
<alloc>=d
d = sent
yield
<free(d)>
<free(b)>
<alloc>=b
b = b * (d * sent )
<free(a)>
yield
<alloc>=a
a = sent
yield
<free(a)>
<alloc>=a
a = arrIter(a[sent])
c[b] = a.get()
<free(c)>
<free(b)>
<free(a)>

{ [yield]: (yield)[yield] = l(yield) } = yield
<alloc>=temp
yield
<alloc>=temp1
temp1 = sent
yield
<alloc>=temp2
temp2 = sent
yield
<alloc>=tempn
tempn = sent
<free(temp)>
yield
<alloc>=temp
temp = objIter(sent)
<free(temp1)>
<alloc>=temp1
temp1 = objIter.get(temp1)
<free(temp1)>
if unORnull(temp1) {
  <alloc>=temp1
  temp1 = l
  yield
  <free(temp1)>
  <alloc>=temp1
  temp1 = temp1(sent)  
}
temp2[tempn] = temp1

[a = {[yield]: e = l()} = yield] = yield
yield
temp = arrIter(sent)
temp1 = temp.get()
if unORnull(temp1) {
  yield
  temp2 = sent
  yield
  temp1 = objIter(sent)
  temp2 = temp1.get(temp2)
  if unORnull(temp2):
     temp2 = l()
  e = temp2
  temp1 = temp1.val
}
a = temp1


