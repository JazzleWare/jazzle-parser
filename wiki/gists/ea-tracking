when in the strict mode, neither 'eval' nor 'arguments' can be assigned to. for example:
```js
eval = 12
```
or
```js
arguments = 12
```
will result in error.

There are more subtle cases though; for example, is 'eval' being assigned first, or is it 'arguments' in the following?
```js
[ eval, arguments = 12 ] = 12
```

it would be surprising to know that, 'eval' is actually being assigned first; the reason is, 'arguments = 12' is not an assignment expression; it is an assignment pattern.

when in the strict mode, however, it does not really matter whether arguments = 12 is an assignment expression or an assignment pattern; if it is the former, it is an immediate error; if it is the former, it means it is being assigned to; either way, an eval-or-arguments (EA henceforwards) is being assigned to, and most won't mind to know which one was first assigned to.

But this is not the ultimate-correct-thing-to-do, even though it works perfectly and the end result, i.e., resulting in an error, is the same as the nitpicking approach that is to be described below.

Before we begin though, there a few terms that should be described. the first is the notion of being in 'param position'; elements of a paren that is not a new-head are in the 'param position' and the containing paren is called a 'param paren' ; all parens except those that are heads of a new are 'param paren's, that is, their elements are all in 'param position'; for example:

```js
(a = b,e * l,c) // is paramParen, with 'a=b' and 'e*l' and 'c' being in the 'param position'
```

but

```js
new (a,b,e)() // (a,b,e) is a new-head, and is not a paramParen
```

Another notion is 'elem position'; elements of an array, and values in an object's properties are in 'elem position'; for example:

```js
[ a = b, e * l, c ] // 'a = b', 'e * l', and 'c' are in 'elem position'

```

Arrays and obj's are called 'containers'; being in the 'elem position' thus simply means 'being an element of a container.'

A few obvious results entail the descriptions above:

* if a container is in 'param position', its elements are also in 'param position', in addition to being in 'elem position'

  ```js
  ([a,b]) // [a,b] is in 'param position', so a and b are in 'param position'
  ([a, [{12: b}, [e]]) [a,[{b},[e]]] is in 'param position', so are 'a' and '[{12: b},[l]]', so are '{12: b}' and '[l]', so are b and l
  ```

* left of every assignment has the same 'param-' or 'elem-' position as the assignment itself:
  ```js
  ([l] = 12) // [l] = 12 is in 'param-position', so '[l]' is in 'param-position'
  [l = 12] // l = 12 is in 'elem-position', so 'l' is in  'elem-position  '
  ``` 

Last is the 'assignment postion'. an id left of '=' is in 'assignment position'; a container left of '=' is in 'assignment position', so are all its members, i.e., anything in the 'elem position' will be in 'assignment position' if its container is in 'assignment position'

The Very Very Last is 'eoa value':
eoa(eval) = eoa(arguments) = itself
eoa(left = expr) = eoa(left)
eoa(id's other than 'eval/arguments') = null
eoa(container) = do {
  var first = [x for x in elems(container) && eoa(x)]
  first.length ? first[0] : null
}
   

The Very Very Really Last is 'first-eval-or-arguments-assigned':
feoaa(eval = expr) = feoaa(arguments = expr) = itself
feoaa(container = expr) =   do {
    var first = [x  for x in elems(container) && eoa(x) ]
    first.length ? first[0] : null
}

feoaa(container) = ${
    var first = [ x for x in elems(container) && feoaa(x) ]
    first.length ? first[0] : null
}

The nitpicker's goal is to find a cheap way to track feoaa, that is, an incremental way to calculate feoaa.

it starts out with the following params:

feoaa = null; // first eval or arguments assigned
prevFeoaa = null; // when parsing container in 'container = expr', feoaa might have been found;before converting container to an assignable, feoaa is saved in 'prevFeoaa'
feoaaContainingAssigment = null; // the latest assignment in whose left the feoaa is located

nitpicker parses containers this way:
     container_feoaa = null
     context = paramContext|CONTEXT_ELEM
     
     while elems can be parsd {
        feoaa = null
        parseElem(context)
        if <no feoaa has been found so far> && <an feoaa has been found now>: current_feoaa = feoaa
     }
     feoaa = container_feoaa

nitpicker parses assignments this way:
   prevFeoaa = feoaa
   assignment_feoaa = feoaa = null
   toAssignable(left)
   assignment_feoaa = feoaa
   %assert left is in 'param position' or 'elem position'  
   feoaa = null
   parseRight()
   feoaa = assignment_feoaa
   feoaaContainingAssignment = <the assignment that has been just parsd>

nitpicker parses nonseqexprs this way:
     parseLeft()
     if parseOp() {
        if o == '=>': parseArrow();
        else if parseAssignment()
        else {
           %assert feoaa == null
           parseRight()
        }
     }

toAssignable(head) {
case   head.type == 'id' {
      head.name in ['eval', 'arguments'] { feoaa = head }
   }

case  head.type == 'mem' { return }

case  head.type == 'obj' {
     obj_feoaa = null
     head.elems.forEach(elem) {
          feoaa = null
          toAssignable(elem.val)
          if <no feoaa found so far> && <an feoaa has been found now>: obj_feoaa = feoaa
     }
     feoaa = obj_feoaa
   }

case head.type == 'arr' {
     arr_feoaa = null
     head.elems.forEach(elem) {
          feoaa = null
          toAssignable(elem)
          if <no feoaa found so far> && <an feoaa has been found now>: arr_feoaa = feoaa
     }
     feoaa = arr_feoaa
    }

case head.type == 'assignment-expression' { // 'assignment expression' is always 'elem', i.e, there is no (l=12)=12 bu rather [ l = 12 ] = 12
     if head == feoaaContainingAssignment { feoaa = prevFeoaa } 
}   
     
the heads for an expr is parsd like:

case lookAhead == '(' { arrowParen = true; parseParen() }
case lookAhead == '[': %fallthrough
case lookAhead == '{' { 
     paramContext = context & CONTEXT_PARAM
     parseContainer(lookAhead) } 

%assert !feoaa || lookAhead not.in [ '.', '(', '[', '`' ]
parseTail()

the paren is parsd like:
paren_feoaa = null

context = CONTEXT_NULLABLE
if arrowParen {
   arrowParen = false
   context |= CONTEXT_PARAM
}

while elems can be parsd {
   feoaa = null
   parseExpr(context) 
   if <no feoaa found before> && <an feoaa has been found now>: paren_feoaa = feoaa
}

feoaa = paren_feoaa

the only case an feoaa will be 'cleaned' without being set to a non-null value is when an arrow is being parsd:
convert_paren_to_params(head)
if feoaa: feoaa = null

feoaa is set after the head is parsed for an expression. if it is non null, it will be an error, unless the expression is in elem or param position, in which case it can only be the head of an assignment

