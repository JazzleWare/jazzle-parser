'arrow.paren.no.arrow'({c:context,u:firstUnassignable, h: head, p:firstParen, prec: prec})
'assignable.unsatisfied'()
'assig.not.simple'(head)
'assig.to.eval.or.arguments'()
'assig.to.eval.or.arguments'(head)
'assig.to.eval.or.arguments'(head)
'assig.unsatisfied'()
'block.dependent.is.unfinished'( n)
'block.dependent.no.opening.curly'()
'block.unfinished'(n)
'break.no.such.label'(label)
'break.not.in.breakable'()
'call.args.is.unfinished'(head,firstParen,firstUnassignable)
'catch.has.no.end.paren'(startc,startLoc,catParam)
'catch.has.no.opening.paren'(startc,startLoc)
'class.mem.name.is.ctor'('gen',startc,startLc)
'class.mem.name.is.ctor'('gen',startc,startLoc)
'class.mem.name.is.ctor'(kind,startc, startLoc)
'class.or.obj.mem.name'(isClass,startc,startLoc)
'class.super.call'()
'class.super.lone'()
'class.super.mem'()
'comment.multi.unfinished' ()
'cond.colon'(cond,context,seq)
'const.not.in.v5'(context)
'const.not.in.v5'(startc,startLoc)
'continue.no.such.label'(label)
'continue.not.a.loop.label'(label)
'continue.not.in.loop'()
'do.has.no.closing.paren'(startc,startLoc,scopeFlags,nbody,c,li,col,cond)
'do.has.no.opening.paren'(startc,startLoc,scopeFlags,nbody)
'do.has.no.while'(startc,startLoc,scopeFlags,nbody)
'export.all.no.from'(startc,startLoc)
'export.all.not.*'(startc,startLoc)
'export.all.source.not.str'(startc,startLoc)
'export.default.const.let'(startc,startLoc)
'export.named.no.exports'(startc,startLoc)
'export.not.in.module'(context)
'for.in.or.of.multi'(startc,startLoc,head)
'for.iter.no.end.paren'(start,startLoc,head,afterHead)
'for.iter.not.of.in'(startc,startLoc,head)
'for.simple.head.is.unsatisfied'(startc,startLoc,head)
'for.simple.no.end.paren'(startc,startLoc,head,afterHead,tail)
'for.simple.no.init.comma'(startc,startLoc,head)
'for.simple.no.test.comma'(startc,startLoc,head,afterHead)
'for.with.no.opening.paren'(startc,startLoc)
'func.args.has.dup'(elem)
'func.args.has.dup'(id)
'func.args.has.dup'(this.argNames[argName])
'func.args.no.end.paren'(argLen,list)
'func.args.no.opening.paren'(argLen)
'func.args.not.enough'(argLen,list)
'func.body.is.empty.expr'(context)
'func.body.is.unfinished'(n)
'func.strict.non.simple.param'()
'hex.esc.byte.not.hex'()
'hex.esc.byte.not.hex'()
'id.esc.must.be.idbody'(peek,c,v)
'id.esc.must.be.idhead'(peek)
'id.multi.must.be.idbody'(peek,byte2,c,v)
'id.multi.must.be.idbody'(peek,byte2,c,v)
'id.multi.must.be.idhead'(peek,r)
'id.slash.no.u'(c,v)
'id.u.not.after.slash'()
'if.has.no.closing.paren'(startc,startLoc)
'if.has.no.opening.paren'(startc,startLoc)
'import.from'(startc,startLoc,list)
'import.namespace.specifier.local.not.id'(startc,startLoc,spStartc,spStartLoc )
'import.namespace.specifier.no.as'(startc,startLoc, spStartc, spStartLoc)
'import.namespace.specifier.not.*'(startc,startLoc)
'import.no.elem.yet.comma'(startc,startLoc)
'import.not.in.module'(context)
'import.specifier.list.unfinished'(startc,startLoc,list)
'import.specifier.local.not.id'(startc,startLoc,local)
'import.specifier.no.as'(startc,startLoc,local)
'incdec.post.not.simple.assig'(arg)
'incdec.pre.not.simple.assig'(c,loc,arg)
'label.is.a.dup'(label,allowNull)
'mem.unfinished'(head,firstParen,firstUnassignable)
'mem.unfinished'(startc,startLoc,head)
'meta.new.has.unknown.prop'(startc,end,startLoc,endLoc,new_raw)
'new.args.is.unfinished'(startc,startLoc,inner)
'new.head.is.not.valid'(startc,startLoc)
'nexpr.null.head'(context,prec)
'no.semi'('continue',startc,startLoc,c,li,col,semi,label)
'no.semi'('continue',startc,startLoc,c,li,col,semi,label)
'no.semi'('debugger',[startc,startLoc,c,li,col] )
'no.semi'('expr',{head:head,e:e})
'no.semi'('import',{s:startc,l:startLoc,list:list,endI:endI,src:src})
'no.semi'('return',[startc,startLoc,c,li,col,semi,retVal] )
'no.semi'(startc,startLoc,c,li,col,semi,label)
'no.semi'(startc,startLoc,c,li,col,semi,label)
'no.semi'('throw',[startc,startLoc,c,li,col,semi,retVal])
'no.semi'('var',[startc,startLoc,kind,list,endI] )
'not.stmt'('break')
'not.stmt'('continue')
'not.stmt'('debugger')
'not.stmt'('do-while')
'not.stmt'('if')
'not.stmt'('import')
'not.stmt'('return')
'not.stmt'('switch')
'not.stmt'('throw')
'not.stmt'('try' )
'not.stmt'('var',context)
'not.stmt'('while')
'not.stmt'('with')
'num.idhead.tail'()
'num.legacy.oct'()
'num.with.first.not.valid'('bin',c)
'num.with.first.not.valid'('hex',c)
'num.with.first.not.valid'('oct',c)
'num.with.no.digits'('bin',c)
'num.with.no.digits'('hex',c)
'num.with.no.digits'('oct',c)
'obj.prop.assig.not.allowed'(name,context)
'obj.prop.assig.not.assigop'(name,context)
'obj.prop.assig.not.id'(name,context)
'obj.proto.has.dup'()
'paren.unfinished'(n)
'pat.array.is.unfinished'(elem)
'pat.obj.is.unfinished'(n)
'program.unfinished'(n)
'prop.dyna.is.unfinished'(n)
'prop.dyna.no.expr'(startc,startLoc)
'regex.flag.is.dup'(startc,startLoc,c)
'regex.flag.is.dup'(startc,startLoc,c)
'regex.flag.is.dup'(startc,startLoc,c)
'regex.flag.is.dup'(startc,startLoc,c)
'regex.flag.is.dup'(startc,startLoc,c)
'regex.not.valid'(startc,startLoc,flagsString,patternString)
'regex.unfinished'(startc,startLoc,c)
'reserved.id'(id)
'rest.has.no.arg'(starc,startLoc)
'return.not.in.a.function'()
'stmt.null'()
'stmt.null'()
'strict.let.is.id'(context)
'strict.oct.str.esc'()
'strict.oct.str.esc'()
'str.newline'(c,startC,v,v_start)
'str.unfinished'(c,v)
'switch.case.has.no.colon'(startc,startLoc,c,li,cond,col)
'switch.has.a.dup.default'(elem)
'switch.has.no.closing.paren'(startc,startLoc)
'switch.has.no.opening.curly'(startc,stratLoc)
'switch.has.no.opening.paren'(startc,startLoc)
'switch.unfinished'(n)
'templ.expr.is.unfinished'()
'templ.lit.is.unfinished'()
'throw.has.newline'(startc,startLoc,c,li,col)
'try.has.no.tail'(startc,startLoc,tryBlock)
'u.curly.is.unfinished'(c,byteVal)
'u.curly.not.in.range'(c,byteVal)
'u.esc.hex'('curly',c,byteVal)
'u.esc.hex'('u',c,byteVal)
'u.esc.hex'('u',c,byteVal)
'u.esc.hex'('u',c,byteVal)
'u.esc.hex'('u',c,byteVal)
'u.second.esc.not.u'()
'u.second.not.in.range'(e)
'var.decl.neither.of.in'(head,init,context)
'var.has.an.empty.declarator'(startc,startLoc,kind,list,context)
'var.has.no.declarators'(startc,startLoc,kind,elem,context)
'while.has.no.closing.paren'(startc,startLoc)
'while.has.no.opening.paren'(startc,startLoc)
'with.has.no.end.paren'(startc,startLoc,obj)
'with.has.no.opening.paren'(startc,startLoc)
'with.strict'()
'yield.as.an.id'(context,prec)
'yield.has.no.expr.deleg'(startc,startLoc,c,li,col,context)
