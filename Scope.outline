Scope {
   parent Scope;
   ownerFunc Scope;
   unresolvedVars map[string]Var
   definedVars map[string]Var
   indirectlyReferencedLexicals {
      names map[string]Var
      list []Var
   }
   synthName string
   isLoop bool
   enum ScopeType {
      SCOPE_CATCH,
      SCOPE_FUNC,
      SCOPE_LEXICAL
   }
   t ScopeType
   if t == SCOPE_FUNC {
      tempNames map[string]bool
      tempSemiStack []string
   }
   if t == SCOPE_CATCH {
      catchVars []Var
   }
}

enum VarDefMode { V_HOISTED, V_LEXICAL }

Scope::ref(name String) Var
Scope::define(name String, vmode VarDefMode) Var
Scope::createSynthName(name string) string
Scope::getTemp()
Scope::releaseTemp(tempName string)

Scope::ref(name string) Var {
   var r = `find(name)
   if r != null: return r
   return `addUnresolved(name)
}

defining in function scope:
Scope::define[SCOPE_FUNC](name) {
   var r = `find(name)
   if r != null {
     %assert vmode != DEF_LET
     return r
   }
   var v = Var new(e)
}

a() :| b()    

{
  var l;
  while (false) {
    let l = 0;
    break
}

{
  var l;
  while (false) {
     var l1_ = 0;
     break;
  }
}

{
  var l;
  while (false) {
    let l = 0;
    (function() { l--; })()
    break;
  }
}

{
  var l, scope = _create_scope(['l']);
  while (false) {
     scope.i();
     scope.d('l', 0);
     (function() {
        var l = scope.l;
        return function() { l.v--; }()
     })();
     break;
  }
}

  
    

