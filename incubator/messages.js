var Errors = {};

Errors['u.token'] = "Unexpected token {0}";
Errors['u.invalid.token'] = "Unexpected {0}";
Errors['u.newline']= "Unexpected line terminator";
Errors['u.eos']= "Unexpected end of input";
Errors['u.num']= "Unexpected #{toktype(arg.tok)}";
Errors['u.newline']= "Unexpected line terminator";
Errors['u.comma.after.rest'] = "Unexpected comma after rest";
Errors['err.throw.newline'] = "Illegal newline after throw";
Errors['err.regex.incompl'] = "Invalid regular expression= missing /";
Errors['err.regex.flags'] = "Invalid regular expression flags";
Errors['err.assig.not'] = "Invalid left-hand side in assignment";
Errors['err.bind.not']= "Invalid left-hand side in binding";
Errors['err.assig.for-in']= "Invalid left-hand side in for-in";
Errors['err.assig.for-of']= "Invalid left-hand side in for-of";
Errors['err.assig.simple.not']= "Increment/decrement target must be an identifier or member expression";
Errors['err.switch.multi']= "More than one default clause in switch statement";
Errors['err.try.tail.no']= "Missing catch or finally after try";
Errors['err.ret.not.allowed'] = "Illegal return statement";
Errors['err.arrow.arg']= "Illegal arrow function parameter list";
Errors['err.for.init.decl'] = "Invalid variable declaration in for-in statement";
Errors['err.prop.init'] = "Illegal property initializer";

Errors['e.class.constructor.dup'] = "Duplicate constructor method in class";
Errors['e.class.super.call'] = "Calls to super must be in the 'constructor' method of a class expression or class declaration that has a superclass";
Errors['e.class.super.acc'] = "Member access on super must be in a method";
Errors['e.bindingdup'] = 'Duplicate binding ${JSON.stringify(node.name)}';
Errors['e.continue'] = "Continue statement must be nested within an iteration statement";
Errors['e.continue.label'] = 'Continue statement must be nested within an iteration statement with label ';
Errors['e.break'] = "Break statement must be nested within an iteration statement or a switch statement";
Errors['e.break.label'] = "Break statement must be nested within a statement with label ${JSON.stringify(node.label)}";
Errors['e.bind.strict'] = "The identifier ${JSON.stringify(node.name)} must not be in binding position in strict mode";
Errors['e.arrow.body.yield'] = "Concise arrow bodies must not contain yield expressions";
Errors['e.arrow.arg.yield'] = "Arrow parameters must not contain yield expressions";
Errors['e.fundef.arg.simple.strict'] = "Functions with non-simple parameter lists may not contain a \"use strict\" directive");
Errors['e.class.constructor.simple'] = "Constructors cannot be generators, getters or setters";
Errors['e.class.static.no.prototype'] = "Static class methods cannot be named \"prototype\"";
Errors['e.labeled-do-while'] = "The body of a do-while statement must not be a labeled function declaration");
Errors['e.const.init'] = "Constant lexical declarations must have an initialiser");
Errors['e.node.body, "The body of a for statement must not be a labeled function declaration");
Errors['e.node.body, "The body of a for-in statement must not be a labeled function declaration");
Errors['e.node.body, "The body of a for-of statement must not be a labeled function declaration");
Errors['e.node, "Generator parameters must not contain yield expressions");
Errors['e.node, "Functions with non-simple parameter lists may not contain a \"use strict\" directive");
Errors['e.dupeNode, `Duplicate binding ${JSON.stringify(bindingName)}`);
Errors['e.node, "Generator parameters must not contain yield expressions");
Errors['e.node, "Functions with non-simple parameter lists may not contain a \"use strict\" directive");
Errors['e.node, `The identifier ${JSON.stringify(node.name)} must not be in expression position in strict mode`);
Errors['e.node.consequent, "The consequent of an if statement must not be a labeled function declaration");
Errors['e.node.alternate, "The alternate of an if statement must not be a labeled function declaration");
Errors['e.node.consequent, "FunctionDeclarations in IfStatements are disallowed in strict mode");
Errors['e.node.alternate, "FunctionDeclarations in IfStatements are disallowed in strict mode");
Errors['e.node, `The identifier ${JSON.stringify(node.label)} must not be in label position in strict mode`);
Errors['e.node, `Label ${JSON.stringify(node.label)} has already been declared`);
Errors['e.node, "Labeled FunctionDeclarations are disallowed in strict mode");
Errors['e.node, "Generator parameters must not contain yield expressions");
Errors['e.node, "Functions with non-simple parameter lists may not contain a \"use strict\" directive");
Errors['e.dupeNode, `Duplicate export ${JSON.stringify(bindingName)}`);
Errors['e.undeclaredNode, `Exported binding ${JSON.stringify(bindingName)} is not declared`);
Errors['e.node, "new.target must be within function (but not arrow expression) code");
Errors['e.n, "Duplicate __proto__ property in object literal not allowed");
Errors['e.node, "Identifier expressions must not be deleted in strict mode");
Errors['e.node, "new.target must be within function (but not arrow expression) code");
Errors['e.node, "Functions with non-simple parameter lists may not contain a \"use strict\" directive");
Errors['e.n, "Lexical declarations must not have a binding named \"let\"");
Errors['e.declarator, "Constant lexical declarations must have an initialiser");
Errors['e.node.body, "The body of a while statement must not be a labeled function declaration");
Errors['e.node.body, "The body of a with statement must not be a labeled function declaration");
Errors['e.node, "Strict mode code must not include a with statement");

